//! Comprehensive edge case tests for consensus protocol
//!\n//! This module contains additional edge case tests to enhance coverage\n//! of the consensus protocol implementation.\n\n#[cfg(test)]\nmod tests {\n    use crate::error::{ConsensusError, ConsensusResult};\n    use crate::leader::{ElectionMessage, LeaderElection, LeaderState};\n    use crate::protocol::{ConsensusMessage, ConsensusProtocol, ConsensusConfig};\n    use crate::validator::{ValidatorId, ValidatorInfo};\n    use crate::voting::{Vote, VoteType, VotingRound, RoundId};\n    use crate::sync::{StateSync, SyncManager};\n    use std::time::Duration;\n    use uuid::Uuid;\n\n    // Leader election edge cases\n    #[test]\n    fn test_leader_election_zero_timeout() {\n        let validator_id = ValidatorId::new();\n        let election = LeaderElection::new(\n            validator_id.clone(),\n            Duration::from_secs(0),\n            Duration::from_secs(0),\n        );\n\n        assert!(election.is_follower());\n        assert_eq!(election.term(), 0);\n    }\n\n    #[test]\n    fn test_leader_election_extreme_timeouts() {\n        let validator_id = ValidatorId::new();\n        let election = LeaderElection::new(\n            validator_id.clone(),\n            Duration::from_secs(86400), // 24 hours\n            Duration::from_nanos(1), // Very small timeout\n        );\n\n        assert!(election.is_follower());\n        assert_eq!(election.term(), 0);\n    }\n\n    #[test]\n    fn test_concurrent_vote_requests() {\n        let validator_id = ValidatorId::new();\n        let mut election = LeaderElection::new(\n            validator_id.clone(),\n            Duration::from_secs(5),\n            Duration::from_secs(1),\n        );\n\n        let candidate1 = ValidatorId::new();\n        let candidate2 = ValidatorId::new();\n        \n        let request1 = ElectionMessage::RequestVote {\n            term: 1,\n            candidate_id: candidate1.clone(),\n            last_log_index: 0,\n            last_log_term: 0,\n        };\n        \n        let request2 = ElectionMessage::RequestVote {\n            term: 1,\n            candidate_id: candidate2.clone(),\n            last_log_index: 0,\n            last_log_term: 0,\n        };\n\n        let response1 = election.handle_message(request1);\n        assert!(response1.is_ok());\n        \n        let response2 = election.handle_message(request2);\n        assert!(response2.is_ok()); \n    }\n\n    #[test]\n    fn test_leader_election_state_consistency() {\n        let validator_id = ValidatorId::new();\n        let mut election = LeaderElection::new(\n            validator_id.clone(),\n            Duration::from_secs(5),\n            Duration::from_secs(1),\n        );\n\n        assert!(election.is_follower());\n        assert!(!election.is_candidate());\n        assert!(!election.is_leader());\n        \n        let _ = election.start_election();\n        assert!(!election.is_follower());\n        assert!(election.is_candidate());\n        assert!(!election.is_leader());\n    }\n\n    #[test]\n    fn test_leader_election_vote_response_edge_cases() {\n        let validator_id = ValidatorId::new();\n        let mut election = LeaderElection::new(\n            validator_id.clone(),\n            Duration::from_secs(5),\n            Duration::from_secs(1),\n        );\n\n        let _ = election.start_election();\n        let current_term = election.term();\n        \n        let old_term_response = ElectionMessage::VoteResponse {\n            term: current_term.saturating_sub(1),\n            vote_granted: true,\n            voter_id: ValidatorId::new(),\n        };\n        \n        let future_term_response = ElectionMessage::VoteResponse {\n            term: current_term + 1,\n            vote_granted: false,\n            voter_id: ValidatorId::new(),\n        };\n        \n        assert!(election.handle_message(old_term_response).is_ok());\n        assert!(election.handle_message(future_term_response).is_ok());\n    }\n\n    // Voting edge cases\n    #[test]\n    fn test_vote_with_nil_value() {\n        let round_id = RoundId::new();\n        let validator_id = ValidatorId::new();\n        \n        let nil_vote = Vote::new(\n            round_id,\n            VoteType::PreVote,\n            validator_id,\n            None, // Nil vote\n            vec![1, 2, 3],\n        );\n        \n        assert!(nil_vote.is_nil());\n        assert!(nil_vote.value_hash.is_none());\n    }\n\n    #[test]\n    fn test_vote_type_serialization() {\n        let vote_types = vec![\n            VoteType::PreVote,\n            VoteType::PreCommit,\n            VoteType::Commit,\n        ];\n        \n        for vote_type in vote_types {\n            let serialized = serde_json::to_string(&vote_type).unwrap();\n            let _deserialized: VoteType = serde_json::from_str(&serialized).unwrap();\n        }\n    }\n\n    #[test]\n    fn test_voting_round_edge_cases() {\n        let round_id = RoundId::new();\n        let mut voting_round = VotingRound::new(round_id.clone(), 3);\n        \n        // Test with zero validators\n        let zero_round = VotingRound::new(RoundId::new(), 0);\n        assert!(!zero_round.has_majority());\n        \n        // Test with single validator\n        let single_round = VotingRound::new(RoundId::new(), 1);\n        assert!(!single_round.has_majority()); // Needs at least one vote\n    }\n\n    #[test]\n    fn test_round_id_edge_cases() {\n        // Test with specific UUID\n        let uuid = Uuid::nil();\n        let round_id = RoundId::from_uuid(uuid);\n        assert_eq!(round_id.as_uuid(), uuid);\n        \n        // Test display formatting\n        let display_str = format!(\"{}\", round_id);\n        assert!(!display_str.is_empty());\n        \n        // Test hash and equality\n        let round_id2 = RoundId::from_uuid(uuid);\n        assert_eq!(round_id, round_id2);\n    }\n\n    // Protocol edge cases\n    #[test]\n    fn test_consensus_config_extreme_values() {\n        let mut config = ConsensusConfig::default();\n        \n        // Test with extreme values\n        config.timeout = Duration::from_nanos(1);\n        config.max_validators = 0;\n        config.byzantine_threshold = 0.0;\n        \n        // Should handle gracefully\n        assert_eq!(config.timeout, Duration::from_nanos(1));\n        assert_eq!(config.max_validators, 0);\n    }\n\n    #[test]\n    fn test_consensus_message_large_payload() {\n        let validator_id = ValidatorId::new();\n        let large_data = vec![42u8; 1_000_000]; // 1MB payload\n        \n        let message = ConsensusMessage::Proposal {\n            term: 1,\n            height: 1,\n            proposer_id: validator_id,\n            value: large_data.clone(),\n            timestamp: 1234567890,\n        };\n        \n        // Should handle large payloads\n        match message {\n            ConsensusMessage::Proposal { value, .. } => {\n                assert_eq!(value.len(), 1_000_000);\n            }\n            _ => panic!(\"Expected Proposal message\"),\n        }\n    }\n\n    #[test]\n    fn test_consensus_message_unicode_data() {\n        let validator_id = ValidatorId::new();\n        let unicode_data = \"Hello, ‰∏ñÁïå! üåçüöÄ\".as_bytes().to_vec();\n        \n        let message = ConsensusMessage::Proposal {\n            term: 1,\n            height: 1,\n            proposer_id: validator_id,\n            value: unicode_data.clone(),\n            timestamp: 1234567890,\n        };\n        \n        // Should handle unicode data\n        let serialized = serde_json::to_string(&message).unwrap();\n        let _deserialized: ConsensusMessage = serde_json::from_str(&serialized).unwrap();\n    }\n\n    // Error handling edge cases\n    #[test]\n    fn test_consensus_error_with_empty_strings() {\n        let error = ConsensusError::ValidationFailed(String::new());\n        assert!(error.to_string().contains(\"Validation failed\"));\n        \n        let byzantine_error = ConsensusError::ByzantineBehavior {\n            validator_id: String::new(),\n            reason: String::new(),\n        };\n        assert!(byzantine_error.to_string().contains(\"Byzantine behavior\"));\n    }\n\n    #[test]\n    fn test_consensus_error_extreme_values() {\n        let error = ConsensusError::InsufficientValidators {\n            required: usize::MAX,\n            available: 0,\n        };\n        \n        let error_str = error.to_string();\n        assert!(error_str.contains(&usize::MAX.to_string()));\n    }\n\n    #[test]\n    fn test_timeout_error_edge_cases() {\n        // Zero duration\n        let zero_timeout = ConsensusError::Timeout {\n            duration: Duration::from_secs(0),\n        };\n        assert!(zero_timeout.to_string().contains(\"0s\"));\n        \n        // Maximum duration\n        let max_timeout = ConsensusError::Timeout {\n            duration: Duration::from_secs(u64::MAX),\n        };\n        assert!(!max_timeout.to_string().is_empty());\n    }\n\n    // Validator edge cases\n    #[test]\n    fn test_validator_info_extreme_cases() {\n        let validator_id = ValidatorId::new();\n        \n        // Test with extreme stake values\n        let zero_stake_validator = ValidatorInfo {\n            id: validator_id.clone(),\n            stake: 0,\n            address: \"127.0.0.1:8080\".to_string(),\n            public_key: vec![],\n            last_seen: 0,\n        };\n        \n        let max_stake_validator = ValidatorInfo {\n            id: validator_id.clone(),\n            stake: u64::MAX,\n            address: \"127.0.0.1:8080\".to_string(),\n            public_key: vec![42u8; 1000], // Large key\n            last_seen: u64::MAX,\n        };\n        \n        assert_eq!(zero_stake_validator.stake, 0);\n        assert_eq!(max_stake_validator.stake, u64::MAX);\n    }\n\n    #[test]\n    fn test_validator_id_uniqueness() {\n        let id1 = ValidatorId::new();\n        let id2 = ValidatorId::new();\n        \n        // Each ID should be unique\n        assert_ne!(id1, id2);\n        \n        // Same ID should be equal to itself\n        assert_eq!(id1, id1.clone());\n    }\n\n    // Sync edge cases\n    #[test]\n    fn test_state_sync_edge_cases() {\n        let sync = StateSync::new();\n        \n        // Test sync status transitions\n        assert!(matches!(sync.status(), crate::sync::SyncStatus::Idle));\n    }\n\n    #[test]\n    fn test_sync_manager_edge_cases() {\n        let config = ConsensusConfig::default();\n        let sync_manager = SyncManager::new(config);\n        \n        // Test with empty peer list\n        let peers = vec![];\n        assert!(sync_manager.sync_with_peers(peers).is_ok());\n    }\n\n    // Integration edge cases\n    #[test]\n    fn test_consensus_protocol_edge_initialization() {\n        let validator_id = ValidatorId::new();\n        let mut config = ConsensusConfig::default();\n        \n        // Test with minimal configuration\n        config.max_validators = 1;\n        config.byzantine_threshold = 0.0;\n        \n        let protocol = ConsensusProtocol::new(validator_id, config);\n        assert!(protocol.is_ok());\n    }\n\n    #[test]\n    fn test_message_handling_stress() {\n        let validator_id = ValidatorId::new();\n        let config = ConsensusConfig::default();\n        let mut protocol = ConsensusProtocol::new(validator_id, config).unwrap();\n        \n        // Send many messages rapidly\n        for i in 0..100 {\n            let message = ConsensusMessage::Proposal {\n                term: i,\n                height: i,\n                proposer_id: ValidatorId::new(),\n                value: vec![i as u8],\n                timestamp: i,\n            };\n            \n            // Should handle without crashing\n            let _ = protocol.handle_message(message);\n        }\n    }\n\n    #[test]\n    fn test_concurrent_access_patterns() {\n        use std::sync::{Arc, Mutex};\n        use std::thread;\n        \n        let validator_id = ValidatorId::new();\n        let config = ConsensusConfig::default();\n        let protocol = Arc::new(Mutex::new(\n            ConsensusProtocol::new(validator_id, config).unwrap()\n        ));\n        \n        let mut handles = vec![];\n        \n        // Spawn multiple threads accessing the protocol\n        for i in 0..5 {\n            let protocol_clone = protocol.clone();\n            let handle = thread::spawn(move || {\n                let message = ConsensusMessage::Proposal {\n                    term: i,\n                    height: i,\n                    proposer_id: ValidatorId::new(),\n                    value: vec![i as u8],\n                    timestamp: i,\n                };\n                \n                if let Ok(mut p) = protocol_clone.lock() {\n                    let _ = p.handle_message(message);\n                }\n            });\n            handles.push(handle);\n        }\n        \n        // Wait for all threads\n        for handle in handles {\n            handle.join().unwrap();\n        }\n    }\n\n    #[test]\n    fn test_memory_usage_patterns() {\n        // Test with many validators\n        let mut validators = vec![];\n        for _ in 0..1000 {\n            validators.push(ValidatorInfo {\n                id: ValidatorId::new(),\n                stake: 100,\n                address: \"127.0.0.1:8080\".to_string(),\n                public_key: vec![42u8; 32],\n                last_seen: 1234567890,\n            });\n        }\n        \n        // Should handle large validator sets\n        assert_eq!(validators.len(), 1000);\n    }\n\n    #[test]\n    fn test_serialization_edge_cases() {\n        // Test serialization with various message types\n        let messages = vec![\n            ConsensusMessage::Proposal {\n                term: 0,\n                height: 0,\n                proposer_id: ValidatorId::new(),\n                value: vec![],\n                timestamp: 0,\n            },\n            ConsensusMessage::Vote {\n                term: u64::MAX,\n                height: u64::MAX,\n                voter_id: ValidatorId::new(),\n                value_hash: Some(\"x\".repeat(1000)),\n                vote_type: VoteType::Commit,\n            },\n        ];\n        \n        for message in messages {\n            let serialized = serde_json::to_string(&message).unwrap();\n            let _deserialized: ConsensusMessage = serde_json::from_str(&serialized).unwrap();\n        }\n    }\n}
