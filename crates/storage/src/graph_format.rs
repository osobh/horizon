//! GPU knowledge graph storage formats

use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

/// Fixed-size node record for efficient storage and GPU access
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct NodeRecord {
    pub id: u64,               // 8 bytes - Unique node identifier
    pub type_id: u32,          // 4 bytes - Node type for schema
    pub flags: u32,            // 4 bytes - Active, archived, etc
    pub created_at: u64,       // 8 bytes - Unix timestamp
    pub last_modified: u64,    // 8 bytes - Unix timestamp
    pub embedding_offset: u64, // 8 bytes - Byte offset in embedding file
    pub property_offset: u64,  // 8 bytes - Byte offset in property file
    pub edge_count: u32,       // 4 bytes - Number of edges
    pub access_count: u32,     // 4 bytes - For cache management
    pub importance_score: f32, // 4 bytes - For pruning decisions
    pub _padding: [u8; 4],     // 4 bytes - 64-byte alignment
} // Total: 64 bytes per node

impl NodeRecord {
    pub const SIZE: usize = 64;

    pub fn new(id: u64, type_id: u32) -> Self {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        Self {
            id,
            type_id,
            flags: 0,
            created_at: now,
            last_modified: now,
            embedding_offset: 0,
            property_offset: 0,
            edge_count: 0,
            access_count: 0,
            importance_score: 0.0,
            _padding: [0; 4],
        }
    }

    /// Convert to bytes for storage
    pub fn to_bytes(&self) -> [u8; Self::SIZE] {
        let mut bytes = [0u8; Self::SIZE];

        bytes[0..8].copy_from_slice(&self.id.to_le_bytes());
        bytes[8..12].copy_from_slice(&self.type_id.to_le_bytes());
        bytes[12..16].copy_from_slice(&self.flags.to_le_bytes());
        bytes[16..24].copy_from_slice(&self.created_at.to_le_bytes());
        bytes[24..32].copy_from_slice(&self.last_modified.to_le_bytes());
        bytes[32..40].copy_from_slice(&self.embedding_offset.to_le_bytes());
        bytes[40..48].copy_from_slice(&self.property_offset.to_le_bytes());
        bytes[48..52].copy_from_slice(&self.edge_count.to_le_bytes());
        bytes[52..56].copy_from_slice(&self.access_count.to_le_bytes());
        bytes[56..60].copy_from_slice(&self.importance_score.to_le_bytes());
        bytes[60..64].copy_from_slice(&self._padding);

        bytes
    }

    /// Create from bytes
    pub fn from_bytes(bytes: &[u8]) -> Option<Self> {
        if bytes.len() < Self::SIZE {
            return None;
        }

        Some(Self {
            id: u64::from_le_bytes(bytes[0..8].try_into().ok()?),
            type_id: u32::from_le_bytes(bytes[8..12].try_into().ok()?),
            flags: u32::from_le_bytes(bytes[12..16].try_into().ok()?),
            created_at: u64::from_le_bytes(bytes[16..24].try_into().ok()?),
            last_modified: u64::from_le_bytes(bytes[24..32].try_into().ok()?),
            embedding_offset: u64::from_le_bytes(bytes[32..40].try_into().ok()?),
            property_offset: u64::from_le_bytes(bytes[40..48].try_into().ok()?),
            edge_count: u32::from_le_bytes(bytes[48..52].try_into().ok()?),
            access_count: u32::from_le_bytes(bytes[52..56].try_into().ok()?),
            importance_score: f32::from_le_bytes(bytes[56..60].try_into().ok()?),
            _padding: bytes[60..64].try_into().ok()?,
        })
    }

    /// Update access count and last modified time
    pub fn mark_accessed(&mut self) {
        self.access_count = self.access_count.saturating_add(1);
        self.last_modified = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
    }
}

/// Node flags
pub mod node_flags {
    pub const ACTIVE: u32 = 1 << 0;
    pub const ARCHIVED: u32 = 1 << 1;
    pub const DELETED: u32 = 1 << 2;
    pub const LOCKED: u32 = 1 << 3;
    pub const SYNTHETIC: u32 = 1 << 4; // Generated by agents
    pub const VERIFIED: u32 = 1 << 5; // Human verified
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_record_size() {
        assert_eq!(std::mem::size_of::<NodeRecord>(), NodeRecord::SIZE);
        assert_eq!(NodeRecord::SIZE, 64);
    }

    #[test]
    fn test_node_record_creation() {
        let node = NodeRecord::new(42, 7);

        assert_eq!(node.id, 42);
        assert_eq!(node.type_id, 7);
        assert_eq!(node.flags, 0);
        assert!(node.created_at > 0);
        assert_eq!(node.last_modified, node.created_at);
        assert_eq!(node.embedding_offset, 0);
        assert_eq!(node.property_offset, 0);
        assert_eq!(node.edge_count, 0);
        assert_eq!(node.access_count, 0);
        assert_eq!(node.importance_score, 0.0);
        assert_eq!(node._padding, [0; 4]);
    }

    #[test]
    fn test_node_record_to_bytes() {
        let node = NodeRecord::new(123, 456);
        let bytes = node.to_bytes();

        assert_eq!(bytes.len(), 64);

        // Check ID serialization
        assert_eq!(&bytes[0..8], &123u64.to_le_bytes());

        // Check type_id serialization
        assert_eq!(&bytes[8..12], &456u32.to_le_bytes());
    }

    #[test]
    fn test_node_record_from_bytes() {
        let original = NodeRecord::new(999, 111);
        let bytes = original.to_bytes();

        let recovered = NodeRecord::from_bytes(&bytes)?;

        assert_eq!(recovered.id, original.id);
        assert_eq!(recovered.type_id, original.type_id);
        assert_eq!(recovered.flags, original.flags);
        assert_eq!(recovered.created_at, original.created_at);
        assert_eq!(recovered.last_modified, original.last_modified);
        assert_eq!(recovered.embedding_offset, original.embedding_offset);
        assert_eq!(recovered.property_offset, original.property_offset);
        assert_eq!(recovered.edge_count, original.edge_count);
        assert_eq!(recovered.access_count, original.access_count);
        assert_eq!(recovered.importance_score, original.importance_score);
        assert_eq!(recovered._padding, original._padding);
    }

    #[test]
    fn test_node_record_from_bytes_too_small() {
        let bytes = vec![0u8; 63]; // One byte too small
        assert!(NodeRecord::from_bytes(&bytes).is_none());
    }

    #[test]
    fn test_node_record_mark_accessed() {
        let mut node = NodeRecord::new(1, 1);
        let original_count = node.access_count;

        // Force a different timestamp by modifying it first
        node.last_modified = node.created_at - 1;
        let original_time = node.last_modified;

        node.mark_accessed();

        assert_eq!(node.access_count, original_count + 1);
        assert!(node.last_modified > original_time);
    }

    #[test]
    fn test_node_flags() {
        let mut node = NodeRecord::new(1, 1);

        // Set multiple flags
        node.flags = node_flags::ACTIVE | node_flags::VERIFIED;

        assert!(node.flags & node_flags::ACTIVE != 0);
        assert!(node.flags & node_flags::VERIFIED != 0);
        assert!(node.flags & node_flags::DELETED == 0);
    }

    #[test]
    fn test_node_record_roundtrip() {
        let mut original = NodeRecord::new(u64::MAX, u32::MAX);
        original.flags = node_flags::ACTIVE | node_flags::SYNTHETIC;
        original.embedding_offset = 12345;
        original.property_offset = 67890;
        original.edge_count = 42;
        original.importance_score = 0.95;

        let bytes = original.to_bytes();
        let recovered = NodeRecord::from_bytes(&bytes)?;

        assert_eq!(original, recovered);
    }
}
