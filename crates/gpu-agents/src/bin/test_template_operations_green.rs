//! Test template operations in synthesis
//!
//! GREEN phase - make tests pass

use cudarc::driver::CudaContext;
use gpu_agents::synthesis::template_ops::{
    register_builtin_functions, CompositeTemplate, TemplateCondition, TemplateEngine,
    TemplateFunction, TemplateLoop,
};
use std::collections::HashMap;

// Helper macro for creating hashmaps
macro_rules! hashmap {
    ($($key:expr => $value:expr),*) => {{
        let mut map = HashMap::new();
        $(map.insert($key.to_string(), $value.to_string());)*
        map
    }};
}

fn main() -> anyhow::Result<()> {
    println!("Testing Template Operations in Synthesis (GREEN phase)");
    println!("====================================================");

    let ctx = CudaContext::new(0)?;

    // Test 1: Create template engine
    println!("\n1. Testing template engine creation...");
    let engine = TemplateEngine::new(ctx.clone())?;
    println!("✅ TemplateEngine created successfully");

    // Test 2: Variable substitution
    println!("\n2. Testing variable substitution...");
    let mut variables = HashMap::new();
    variables.insert("name".to_string(), "Alice".to_string());
    variables.insert("age".to_string(), "30".to_string());

    let template = "Hello {{name}}, you are {{age}} years old.";
    let result = engine.substitute_variables(template, &variables)?;
    println!("✅ Variable substitution: '{}'", result);
    assert_eq!(result, "Hello Alice, you are 30 years old.");

    // Test 3: Conditional templates
    println!("\n3. Testing conditional templates...");
    let condition = TemplateCondition::new("has_gpu", true);
    let if_template = "GPU acceleration enabled";
    let else_template = "Running on CPU";

    let result = engine.evaluate_condition(&condition, if_template, else_template)?;
    println!("✅ Conditional (true): '{}'", result);
    assert_eq!(result, "GPU acceleration enabled");

    let condition_false = TemplateCondition::new("has_gpu", false);
    let result2 = engine.evaluate_condition(&condition_false, if_template, else_template)?;
    println!("✅ Conditional (false): '{}'", result2);
    assert_eq!(result2, "Running on CPU");

    // Test 4: Loop templates
    println!("\n4. Testing loop templates...");
    let items = vec!["apple", "banana", "orange"];
    let loop_template = TemplateLoop::new("fruits", items);
    let item_template = "- {{item}}";

    let result = engine.expand_loop(&loop_template, item_template)?;
    println!("✅ Loop expansion:\n{}", result);
    assert!(result.contains("apple"));
    assert!(result.contains("banana"));
    assert!(result.contains("orange"));
    assert_eq!(result.lines().count(), 3);

    // Test 5: Template functions
    println!("\n5. Testing template functions...");

    // Register built-in functions
    register_builtin_functions(&engine)?;

    // Test uppercase function
    let template = "{{uppercase(name)}}";
    let result = engine.apply_functions(template, &variables)?;
    println!("✅ Uppercase function: '{}'", result);
    assert_eq!(result, "ALICE");

    // Test custom function
    let custom_func = TemplateFunction::new("repeat", |s: &str| s.repeat(3));
    engine.register_function(custom_func)?;

    let template2 = "{{repeat(name)}}";
    let result2 = engine.apply_functions(template2, &variables)?;
    println!("✅ Custom repeat function: '{}'", result2);
    assert_eq!(result2, "AliceAliceAlice");

    // Test 6: Composite templates
    println!("\n6. Testing composite templates...");
    let mut comp_vars = HashMap::new();
    comp_vars.insert("title".to_string(), "Test Document".to_string());
    comp_vars.insert("content".to_string(), "This is the content".to_string());
    comp_vars.insert("generator".to_string(), "TemplateEngine".to_string());

    let composite = CompositeTemplate::new()
        .add_template("header", "# {{title}}")
        .add_template("body", "{{content}}")
        .add_template("footer", "---\nGenerated by {{generator}}");

    let result = engine.render_composite(&composite, &comp_vars)?;
    println!("✅ Composite rendering:\n{}", result);
    assert!(result.contains("# Test Document"));
    assert!(result.contains("This is the content"));
    assert!(result.contains("Generated by TemplateEngine"));

    // Test 7: GPU-accelerated template expansion
    println!("\n7. Testing GPU-accelerated template expansion...");
    let templates = vec!["Hello {{name}}", "Welcome {{user}}", "Goodbye {{person}}"];
    let batch_vars = vec![
        hashmap! {"name" => "Alice"},
        hashmap! {"user" => "Bob"},
        hashmap! {"person" => "Charlie"},
    ];

    let results = engine.gpu_batch_expand(&templates, &batch_vars)?;
    println!("✅ Batch expansion results:");
    for (i, result) in results.iter().enumerate() {
        println!("   [{}] {}", i, result);
    }
    assert_eq!(results.len(), 3);
    assert_eq!(results[0], "Hello Alice");
    assert_eq!(results[1], "Welcome Bob");
    assert_eq!(results[2], "Goodbye Charlie");

    // Test 8: Complex template with multiple features
    println!("\n8. Testing complex template features...");
    let mut complex_vars = HashMap::new();
    complex_vars.insert("project".to_string(), "StratoSwarm".to_string());
    complex_vars.insert("version".to_string(), "1.0".to_string());
    complex_vars.insert("author".to_string(), "gpu-agents".to_string());

    // Test nested variables
    let template = "{{project}} v{{version}} by {{uppercase(author)}}";
    let result = engine.apply_functions(template, &complex_vars)?;
    println!("✅ Complex template: '{}'", result);
    assert_eq!(result, "StratoSwarm v1.0 by GPU-AGENTS");

    // Test loop with index
    let mut indexed_loop = TemplateLoop::new("items", vec!["first", "second", "third"]);
    indexed_loop.index_var = Some("idx".to_string());
    let indexed_template = "[{{idx}}] {{item}}";
    let result = engine.expand_loop(&indexed_loop, indexed_template)?;
    println!("✅ Indexed loop:\n{}", result);
    assert!(result.contains("[0] first"));
    assert!(result.contains("[1] second"));
    assert!(result.contains("[2] third"));

    // Test 9: Performance metrics
    println!("\n9. Testing template performance...");
    let start = std::time::Instant::now();

    // Batch process many templates
    let perf_templates: Vec<&str> = (0..100).map(|i| "Template {{num}}").collect();
    let perf_vars: Vec<HashMap<String, String>> = (0..100)
        .map(|i| {
            let mut vars = HashMap::new();
            vars.insert("num".to_string(), i.to_string());
            vars
        })
        .collect();

    let perf_results = engine.gpu_batch_expand(&perf_templates, &perf_vars)?;
    let elapsed = start.elapsed();

    println!(
        "✅ Processed {} templates in {:?}",
        perf_results.len(),
        elapsed
    );
    println!(
        "   Average: {:.2} μs/template",
        elapsed.as_micros() as f64 / perf_results.len() as f64
    );

    assert_eq!(perf_results.len(), 100);
    assert_eq!(perf_results[0], "Template 0");
    assert_eq!(perf_results[99], "Template 99");

    // Test 10: Error handling
    println!("\n10. Testing error handling...");

    // Test with mismatched template/variable counts
    let bad_templates = vec!["{{a}}", "{{b}}"];
    let bad_vars = vec![hashmap! {"a" => "1"}]; // Only 1 var set for 2 templates

    match engine.gpu_batch_expand(&bad_templates, &bad_vars) {
        Err(e) => println!("✅ Correctly caught error: {}", e),
        Ok(_) => panic!("Should have failed with mismatched counts"),
    }

    println!("\n✅ All GREEN phase tests passed!");
    println!("\nKey achievements:");
    println!("- Variable substitution working");
    println!("- Conditional templates functional");
    println!("- Loop expansion with optional indexing");
    println!("- Template functions (built-in and custom)");
    println!("- Composite template rendering");
    println!("- GPU batch processing");
    println!(
        "- Performance: ~{:.0} templates/sec",
        100.0 / elapsed.as_secs_f64()
    );

    Ok(())
}
