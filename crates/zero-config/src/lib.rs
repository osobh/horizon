//! # StratoSwarm Zero-Config Intelligence
//!
//! This crate implements intelligent code analysis and behavioral learning to eliminate
//! configuration files. The system analyzes code repositories, learns from deployment
//! patterns, and automatically generates optimal agent configurations.

pub mod analysis;
pub mod config_generation;
pub mod crate_validator;
pub mod dependency_classification;
pub mod dependency_parsers;
pub mod documentation_validator;
pub mod error;
pub mod file_splitter;
pub mod language_detection;
pub mod learning;
pub mod memory_migration;
pub mod pattern_recognition;
pub mod resource_estimation;

// Re-export main types
pub use analysis::CodeAnalyzer;
pub use config_generation::{AgentConfigBuilder, ConfigGenerator};
pub use dependency_parsers::DependencyAnalyzer;
pub use error::{Result, ZeroConfigError};
pub use language_detection::{LanguageDetector, LanguageInfo};
pub use learning::{
    BehavioralLearner, DeploymentOutcome, DeploymentPattern, KnowledgeTransfer, PatternCollector,
};
pub use pattern_recognition::{PatternRecognizer, SimilarityEngine};
pub use resource_estimation::ResourceEstimator;

/// Main entry point for zero-config intelligence
pub struct ZeroConfigEngine {
    analyzer: CodeAnalyzer,
    learner: BehavioralLearner,
    generator: ConfigGenerator,
}

impl ZeroConfigEngine {
    /// Create a new zero-config engine
    pub fn new() -> Self {
        Self {
            analyzer: CodeAnalyzer::new(),
            learner: BehavioralLearner::new(),
            generator: ConfigGenerator::new(),
        }
    }

    /// Analyze a codebase and generate optimal configuration
    pub async fn analyze_and_configure(&self, path: &str) -> Result<AgentConfiguration> {
        // Step 1: Analyze the codebase
        let analysis = self.analyzer.analyze_codebase(path).await?;

        // Step 2: Find similar patterns from learning system
        let patterns = self.learner.find_similar_patterns(&analysis).await?;

        // Step 3: Generate configuration based on analysis and patterns
        let config = self.generator.generate_config(analysis, patterns).await?;

        Ok(config)
    }

    /// Learn from a successful deployment
    pub async fn learn_from_deployment(&mut self, deployment: DeploymentOutcome) -> Result<()> {
        self.learner.record_deployment(deployment).await
    }
}

impl Default for ZeroConfigEngine {
    fn default() -> Self {
        Self::new()
    }
}

/// Final agent configuration generated by the zero-config system
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AgentConfiguration {
    pub agent_id: String,
    pub language: String,
    pub framework: Option<String>,
    pub dependencies: Vec<Dependency>,
    pub resources: ResourceRequirements,
    pub scaling: ScalingPolicy,
    pub networking: NetworkConfiguration,
    pub storage: StorageConfiguration,
    pub personality: PersonalityConfig,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Dependency {
    pub name: String,
    pub version: Option<String>,
    pub dependency_type: DependencyType,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub enum DependencyType {
    Database,
    Cache,
    MessageQueue,
    WebFramework,
    MLFramework,
    ImageProcessing,
    VideoProcessing,
    GameEngine,
    Other(String),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ResourceRequirements {
    pub cpu_cores: f32,
    pub memory_gb: f32,
    pub gpu_units: f32,
    pub storage_gb: f32,
    pub network_bandwidth_mbps: f32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ScalingPolicy {
    pub min_replicas: u32,
    pub max_replicas: u32,
    pub target_cpu_percent: f32,
    pub scale_up_threshold: f32,
    pub scale_down_threshold: f32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct NetworkConfiguration {
    pub expose_ports: Vec<u16>,
    pub ingress_rules: Vec<IngressRule>,
    pub service_mesh: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct IngressRule {
    pub path: String,
    pub methods: Vec<String>,
    pub rate_limit: Option<u32>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StorageConfiguration {
    pub persistent_volumes: Vec<PersistentVolume>,
    pub temporary_storage_gb: f32,
    pub backup_policy: BackupPolicy,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersistentVolume {
    pub mount_path: String,
    pub size_gb: f32,
    pub storage_class: StorageClass,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum StorageClass {
    Gpu,
    Cpu,
    Nvme,
    Ssd,
    Hdd,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct BackupPolicy {
    pub enabled: bool,
    pub frequency: BackupFrequency,
    pub retention_days: u32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum BackupFrequency {
    Hourly,
    Daily,
    Weekly,
    Never,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PersonalityConfig {
    pub risk_tolerance: f32,
    pub cooperation: f32,
    pub exploration: f32,
    pub efficiency_focus: f32,
    pub stability_preference: f32,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DeploymentMetrics {
    pub startup_time_ms: u64,
    pub avg_cpu_usage: f32,
    pub avg_memory_usage_gb: f32,
    pub error_rate: f32,
    pub throughput_rps: f32,
    pub latency_p99_ms: u64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_zero_config_engine_creation() {
        let engine = ZeroConfigEngine::new();
        assert!(engine.analyzer.supported_languages().len() > 0);
    }

    #[tokio::test]
    async fn test_analyze_rust_project() {
        let temp_dir = TempDir::new().unwrap();
        let cargo_toml = r#"
[package]
name = "test-app"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = "1.0"
serde = "1.0"
"#;

        let main_rs = r#"
use tokio;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Config {
    port: u16,
    host: String,
}

#[tokio::main]
async fn main() {
    println!("Hello, world!");
}
"#;

        fs::write(temp_dir.path().join("Cargo.toml"), cargo_toml).unwrap();
        fs::create_dir(temp_dir.path().join("src")).unwrap();
        fs::write(temp_dir.path().join("src").join("main.rs"), main_rs).unwrap();

        let engine = ZeroConfigEngine::new();
        let config = engine
            .analyze_and_configure(temp_dir.path().to_str().unwrap())
            .await
            .unwrap();

        assert_eq!(config.language, "rust");
        assert!(config.dependencies.iter().any(|d| d.name == "tokio"));
        assert!(config.dependencies.iter().any(|d| d.name == "serde"));
        assert!(config.resources.cpu_cores > 0.0);
        assert!(config.resources.memory_gb > 0.0);
    }

    #[tokio::test]
    async fn test_analyze_python_project() {
        let temp_dir = TempDir::new().unwrap();
        let requirements = r#"
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.5.0
sqlalchemy==2.0.23
"#;

        let main_py = r#"
from fastapi import FastAPI
from pydantic import BaseModel
import sqlalchemy

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float

@app.get("/")
async def root():
    return {"message": "Hello World"}

@app.post("/items/")
async def create_item(item: Item):
    return item
"#;

        fs::write(temp_dir.path().join("requirements.txt"), requirements).unwrap();
        fs::write(temp_dir.path().join("main.py"), main_py).unwrap();

        let engine = ZeroConfigEngine::new();
        let config = engine
            .analyze_and_configure(temp_dir.path().to_str().unwrap())
            .await
            .unwrap();

        assert_eq!(config.language, "python");
        assert!(config.dependencies.iter().any(|d| d.name == "fastapi"));
        assert!(config.dependencies.iter().any(|d| d.name == "sqlalchemy"));
        assert!(config.networking.expose_ports.contains(&8080));
    }

    #[tokio::test]
    async fn test_learning_from_deployment() {
        let mut engine = ZeroConfigEngine::new();

        let config = AgentConfiguration {
            agent_id: "test-agent-001".to_string(),
            language: "rust".to_string(),
            framework: Some("tokio".to_string()),
            dependencies: vec![],
            resources: ResourceRequirements {
                cpu_cores: 2.0,
                memory_gb: 4.0,
                gpu_units: 0.0,
                storage_gb: 10.0,
                network_bandwidth_mbps: 100.0,
            },
            scaling: ScalingPolicy {
                min_replicas: 2,
                max_replicas: 10,
                target_cpu_percent: 70.0,
                scale_up_threshold: 80.0,
                scale_down_threshold: 30.0,
            },
            networking: NetworkConfiguration {
                expose_ports: vec![8080],
                ingress_rules: vec![],
                service_mesh: false,
            },
            storage: StorageConfiguration {
                persistent_volumes: vec![],
                temporary_storage_gb: 1.0,
                backup_policy: BackupPolicy {
                    enabled: false,
                    frequency: BackupFrequency::Never,
                    retention_days: 0,
                },
            },
            personality: PersonalityConfig {
                risk_tolerance: 0.5,
                cooperation: 0.7,
                exploration: 0.3,
                efficiency_focus: 0.6,
                stability_preference: 0.8,
            },
        };

        let deployment = DeploymentOutcome {
            config,
            metrics: DeploymentMetrics {
                startup_time_ms: 2000,
                avg_cpu_usage: 0.4,
                avg_memory_usage_gb: 1.2,
                error_rate: 0.01,
                throughput_rps: 1000.0,
                latency_p99_ms: 50,
            },
            success: true,
            issues: vec![],
            improvements: vec!["Could reduce memory allocation".to_string()],
        };

        let result = engine.learn_from_deployment(deployment).await;
        assert!(result.is_ok());
    }

    #[test]
    fn test_agent_configuration_serialization() {
        let config = AgentConfiguration {
            agent_id: "test-001".to_string(),
            language: "rust".to_string(),
            framework: None,
            dependencies: vec![Dependency {
                name: "tokio".to_string(),
                version: Some("1.0".to_string()),
                dependency_type: DependencyType::Other("async-runtime".to_string()),
            }],
            resources: ResourceRequirements {
                cpu_cores: 1.0,
                memory_gb: 2.0,
                gpu_units: 0.0,
                storage_gb: 5.0,
                network_bandwidth_mbps: 50.0,
            },
            scaling: ScalingPolicy {
                min_replicas: 1,
                max_replicas: 5,
                target_cpu_percent: 70.0,
                scale_up_threshold: 80.0,
                scale_down_threshold: 30.0,
            },
            networking: NetworkConfiguration {
                expose_ports: vec![8080],
                ingress_rules: vec![],
                service_mesh: false,
            },
            storage: StorageConfiguration {
                persistent_volumes: vec![],
                temporary_storage_gb: 1.0,
                backup_policy: BackupPolicy {
                    enabled: false,
                    frequency: BackupFrequency::Never,
                    retention_days: 0,
                },
            },
            personality: PersonalityConfig {
                risk_tolerance: 0.5,
                cooperation: 0.7,
                exploration: 0.3,
                efficiency_focus: 0.6,
                stability_preference: 0.8,
            },
        };

        let json = serde_json::to_string(&config).unwrap();
        let deserialized: AgentConfiguration = serde_json::from_str(&json).unwrap();

        assert_eq!(config.agent_id, deserialized.agent_id);
        assert_eq!(config.language, deserialized.language);
        assert_eq!(config.dependencies.len(), deserialized.dependencies.len());
    }

    #[test]
    fn test_resource_requirements_validation() {
        let resources = ResourceRequirements {
            cpu_cores: 0.5,
            memory_gb: 1.0,
            gpu_units: 0.0,
            storage_gb: 1.0,
            network_bandwidth_mbps: 10.0,
        };

        assert!(resources.cpu_cores > 0.0);
        assert!(resources.memory_gb > 0.0);
        assert!(resources.storage_gb > 0.0);
        assert!(resources.network_bandwidth_mbps > 0.0);
    }

    #[test]
    fn test_scaling_policy_validation() {
        let scaling = ScalingPolicy {
            min_replicas: 2,
            max_replicas: 10,
            target_cpu_percent: 70.0,
            scale_up_threshold: 80.0,
            scale_down_threshold: 30.0,
        };

        assert!(scaling.min_replicas <= scaling.max_replicas);
        assert!(scaling.scale_down_threshold < scaling.scale_up_threshold);
        assert!(scaling.target_cpu_percent > 0.0 && scaling.target_cpu_percent <= 100.0);
    }

    #[test]
    fn test_personality_config_ranges() {
        let personality = PersonalityConfig {
            risk_tolerance: 0.8,
            cooperation: 0.6,
            exploration: 0.4,
            efficiency_focus: 0.7,
            stability_preference: 0.9,
        };

        assert!(personality.risk_tolerance >= 0.0 && personality.risk_tolerance <= 1.0);
        assert!(personality.cooperation >= 0.0 && personality.cooperation <= 1.0);
        assert!(personality.exploration >= 0.0 && personality.exploration <= 1.0);
        assert!(personality.efficiency_focus >= 0.0 && personality.efficiency_focus <= 1.0);
        assert!(personality.stability_preference >= 0.0 && personality.stability_preference <= 1.0);
    }

    #[test]
    fn test_storage_class_enum() {
        let classes = vec![
            StorageClass::Gpu,
            StorageClass::Cpu,
            StorageClass::Nvme,
            StorageClass::Ssd,
            StorageClass::Hdd,
        ];

        // Test serialization
        for class in classes {
            let json = serde_json::to_string(&class).unwrap();
            let _deserialized: StorageClass = serde_json::from_str(&json).unwrap();
        }
    }

    #[test]
    fn test_dependency_type_enum() {
        let types = vec![
            DependencyType::Database,
            DependencyType::Cache,
            DependencyType::MessageQueue,
            DependencyType::WebFramework,
            DependencyType::MLFramework,
            DependencyType::Other("custom".to_string()),
        ];

        for dep_type in types {
            let json = serde_json::to_string(&dep_type).unwrap();
            let _deserialized: DependencyType = serde_json::from_str(&json).unwrap();
        }
    }
}
